--- a/Abort.hpp
+++ b/Abort.hpp
@@ -7,9 +7,14 @@

 namespace sf::base
 {
-////////////////////////////////////////////////////////////
+////////////////////////////////////////////////////////////
+/// \brief Immediately terminate the current process abnormally
+///
+/// This function calls `std::abort()`. It is used internally
+/// by SFML for irrecoverable errors, such as failed assertions
+/// in debug mode.
+///
 ////////////////////////////////////////////////////////////
 [[noreturn, gnu::cold, gnu::noinline]] void abort() noexcept;

 } // namespace sf::base
+
--- a/Algorithm.hpp
+++ b/Algorithm.hpp
@@ -11,6 +11,14 @@
 namespace sf::base
 {
 ////////////////////////////////////////////////////////////
+/// \brief Copy elements from one range to another
+///
+/// \param rangeBegin Iterator to the beginning of the source range
+/// \param rangeEnd   Iterator to the end of the source range
+/// \param targetIter Iterator to the beginning of the destination range
+///
+/// \return Iterator to the element past the last element copied
+///
 ////////////////////////////////////////////////////////////
 template <typename Iter, typename TargetIter>
 [[gnu::always_inline]] constexpr TargetIter copy(Iter rangeBegin, Iter rangeEnd, TargetIter targetIter)
@@ -22,6 +30,14 @@


 ////////////////////////////////////////////////////////////
+/// \brief Find the first element equal to a target value in a range
+///
+/// \param rangeBegin Iterator to the beginning of the range
+/// \param rangeEnd   Iterator to the end of the range
+/// \param target     Value to search for
+///
+/// \return Iterator to the first element equal to target, or rangeEnd if not found
+///
 ////////////////////////////////////////////////////////////
 template <typename Iter, typename T>
 [[nodiscard, gnu::always_inline, gnu::pure]] constexpr Iter find(Iter rangeBegin, Iter rangeEnd, const T& target) noexcept
@@ -34,6 +50,14 @@


 ////////////////////////////////////////////////////////////
+/// \brief Find the first element satisfying a predicate in a range
+///
+/// \param rangeBegin Iterator to the beginning of the range
+/// \param rangeEnd   Iterator to the end of the range
+/// \param predicate  Unary predicate function
+///
+/// \return Iterator to the first element for which predicate returns true, or rangeEnd if not found
+///
 ////////////////////////////////////////////////////////////
 template <typename Iter, typename Predicate>
 [[nodiscard, gnu::always_inline, gnu::pure]] constexpr Iter findIf(Iter rangeBegin, Iter rangeEnd, Predicate&& predicate) noexcept
@@ -46,6 +70,14 @@


 ////////////////////////////////////////////////////////////
+/// \brief Check if any element in a range satisfies a predicate
+///
+/// \param rangeBegin Iterator to the beginning of the range
+/// \param rangeEnd   Iterator to the end of the range
+/// \param predicate  Unary predicate function
+///
+/// \return `true` if predicate returns true for at least one element, `false` otherwise
+///
 ////////////////////////////////////////////////////////////
 template <typename Iter, typename Predicate>
 [[nodiscard, gnu::always_inline, gnu::pure]] constexpr bool anyOf(Iter rangeBegin, Iter rangeEnd, Predicate&& predicate) noexcept
@@ -58,6 +90,14 @@


 ////////////////////////////////////////////////////////////
+/// \brief Count the number of elements in a range that evaluate to true
+///
+/// Iterates through the range and increments a counter for each element
+/// that, when converted to bool, is true.
+///
+/// \param rangeBegin Iterator to the beginning of the range
+/// \param rangeEnd   Iterator to the end of the range
+///
+/// \return The number of elements evaluating to true
+///
 ////////////////////////////////////////////////////////////
 template <typename Iter>
 [[nodiscard, gnu::always_inline, gnu::pure]] constexpr SizeT countTruthy(Iter rangeBegin, Iter rangeEnd)
@@ -72,6 +112,14 @@


 ////////////////////////////////////////////////////////////
+/// \brief Count the number of elements in a range equal to a specific value
+///
+/// \param rangeBegin Iterator to the beginning of the range
+/// \param rangeEnd   Iterator to the end of the range
+/// \param value      Value to compare elements against
+///
+/// \return The number of elements equal to value
+///
 ////////////////////////////////////////////////////////////
 template <typename Iter, typename T>
 [[nodiscard, gnu::always_inline, gnu::pure]] constexpr SizeT count(Iter rangeBegin, Iter rangeEnd, const T& value)
@@ -86,6 +134,14 @@


 ////////////////////////////////////////////////////////////
+/// \brief Count the number of elements in a range satisfying a predicate
+///
+/// \param rangeBegin Iterator to the beginning of the range
+/// \param rangeEnd   Iterator to the end of the range
+/// \param predicate  Unary predicate function
+///
+/// \return The number of elements for which predicate returns true
+///
 ////////////////////////////////////////////////////////////
 template <typename Iter, typename Predicate>
 [[nodiscard, gnu::always_inline, gnu::pure]] constexpr SizeT countIf(Iter rangeBegin, Iter rangeEnd, Predicate&& predicate)
@@ -100,6 +156,14 @@


 ////////////////////////////////////////////////////////////
+/// \brief Check if all elements in a range satisfy a predicate
+///
+/// \param rangeBegin Iterator to the beginning of the range
+/// \param rangeEnd   Iterator to the end of the range
+/// \param predicate  Unary predicate function
+///
+/// \return `true` if predicate returns true for all elements, `false` otherwise
+///
 ////////////////////////////////////////////////////////////
 template <typename Iter, typename Predicate>
 [[nodiscard, gnu::always_inline, gnu::pure]] constexpr bool allOf(Iter rangeBegin, Iter rangeEnd, Predicate&& predicate) noexcept
@@ -112,6 +176,12 @@


 ////////////////////////////////////////////////////////////
+/// \brief Get the size of a C-style array at compile time
+///
+/// \param Array reference
+///
+/// \return Size of the array (number of elements)
+///
 ////////////////////////////////////////////////////////////
 template <typename T, auto N>
 [[nodiscard, gnu::always_inline, gnu::const]] consteval SizeT getArraySize(const T (&)[N]) noexcept
@@ -121,6 +191,12 @@


 ////////////////////////////////////////////////////////////
+/// \brief Get the size of a C-style array member at compile time
+///
+/// \param Pointer to array member
+///
+/// \return Size of the array member (number of elements)
+///
 ////////////////////////////////////////////////////////////
 template <typename S, typename T, auto N>
 [[nodiscard, gnu::always_inline, gnu::const]] consteval auto getArraySize(const T (S::*)[N]) noexcept
@@ -130,6 +206,11 @@


 ////////////////////////////////////////////////////////////
+/// \brief Output iterator that inserts elements using `push_back`
+///
+/// Acts like `std::back_insert_iterator`.
+///
+////////////////////////////////////////////////////////////
 template <typename T>
 class BackInserter
 {
@@ -140,34 +221,47 @@
     using container_type = T;
     using value_type     = T::value_type;

+    /// \brief Construct a `BackInserter` for a container
+    /// \param container Container to insert into
     [[nodiscard, gnu::always_inline]] explicit BackInserter(T& container) noexcept : m_container(&container)
     {
     }

+    /// \brief Assignment operator, performs the insertion
+    /// \param value Value to insert
+    /// \return Reference to `*this`
     [[gnu::always_inline]] BackInserter& operator=(const value_type& value)
     {
         m_container->push_back(value);
         return *this;
     }

+    /// \brief Move assignment operator, performs the insertion
+    /// \param value Value to move-insert
+    /// \return Reference to `*this`
     [[gnu::always_inline]] BackInserter& operator=(value_type&& value)
     {
         m_container->push_back(static_cast<value_type&&>(value));
         return *this;
     }

+    /// \brief Dereference operator (no-op)
+    /// \return Reference to `*this`
     [[nodiscard, gnu::always_inline, gnu::pure]] BackInserter& operator*() noexcept
     {
         return *this;
     }

+    /// \brief Pre-increment operator (no-op)
+    /// \return Reference to `*this`
     [[gnu::always_inline, gnu::pure]] BackInserter& operator++() noexcept
     {
         return *this;
     }

+    /// \brief Post-increment operator (no-op)
+    /// \return Copy of `*this` before operation
     [[nodiscard, gnu::always_inline, gnu::pure]] BackInserter operator++(int) noexcept
     {
         return *this;
@@ -176,6 +270,15 @@


 ////////////////////////////////////////////////////////////
+/// \brief Exchange the value of an object with a new value
+///
+/// Assigns `newVal` to `obj` and returns the old value of `obj`.
+/// Equivalent to `std::exchange`.
+///
+/// \param obj    Object whose value to exchange
+/// \param newVal New value to assign to `obj`
+///
+/// \return The old value of `obj`
+///
 ////////////////////////////////////////////////////////////
 template <typename T, typename U = T>
 [[nodiscard, gnu::always_inline]] inline constexpr T exchange(T& obj, U&& newVal)
@@ -187,6 +290,17 @@


 ////////////////////////////////////////////////////////////
+/// \brief Remove elements satisfying a predicate from a range
+///
+/// Moves elements for which the predicate is false to the beginning
+/// of the range `[first, last)`. Returns an iterator to the new logical
+/// end of the range. The elements after the returned iterator are in
+/// a valid but unspecified state.
+/// Equivalent to `std::remove_if`.
+///
+/// \param first     Iterator to the beginning of the range
+/// \param last      Iterator to the end of the range
+/// \param predicate Unary predicate function
+///
+/// \return Iterator to the new logical end of the range
+///
 ////////////////////////////////////////////////////////////
 template <typename Iter, typename Predicate>
 [[nodiscard, gnu::always_inline]] inline constexpr Iter removeIf(Iter first, Iter last, Predicate&& predicate)
@@ -202,6 +316,16 @@


 ////////////////////////////////////////////////////////////
+/// \brief Erase elements satisfying a predicate from a vector
+///
+/// Removes all elements from the vector for which the predicate
+/// returns `true`. This function modifies the vector in-place.
+/// Equivalent to `std::erase_if` for vectors.
+///
+/// \param vector    Vector to modify
+/// \param predicate Unary predicate function
+///
+/// \return The number of elements removed
+///
 ////////////////////////////////////////////////////////////
 template <typename Vector, typename Predicate>
 [[gnu::always_inline]] inline constexpr SizeT vectorEraseIf(Vector& vector, Predicate&& predicate)
@@ -214,6 +338,14 @@


 ////////////////////////////////////////////////////////////
+/// \brief Check if a range is sorted according to a comparison function
+///
+/// \param first Iterator to the beginning of the range
+/// \param last  Iterator to the end of the range
+/// \param comp  Binary comparison function object
+///
+/// \return `true` if the range is sorted, `false` otherwise
+///
 ////////////////////////////////////////////////////////////
 template <typename Iter, typename Comparer>
 [[nodiscard]] constexpr bool isSorted(Iter first, Iter last, Comparer comp)
--- a/AnchorPointMixin.hpp
+++ b/AnchorPointMixin.hpp
@@ -10,6 +10,18 @@

 namespace sf
 {
+////////////////////////////////////////////////////////////
+/// \brief Utility mixin providing anchor point functions for positioning
+///
+/// This template class can be inherited by classes that have position
+/// and bounds (like `sf::Transformable` based classes or `sf::WindowBase`)
+/// to add convenient functions for getting and setting the object's position
+/// based on common anchor points (corners, centers, edges).
+///
+/// It relies on the inheriting class `T` providing `getGlobalBounds()`
+/// (or `getSize()` for `sf::WindowBase`) and having a `position` member.
+///
+////////////////////////////////////////////////////////////
 ////////////////////////////////////////////////////////////
 template <typename T>
 struct AnchorPointMixin
@@ -23,6 +35,16 @@
     ////////////////////////////////////////////////////////////
     /// \brief Get the position of a specific anchor point
     ///
+    /// Calculates the world coordinates of a point based on normalized
+    /// factors within the object's bounding box (or size for windows).
+    /// (0, 0) corresponds to the top-left, (1, 1) to the bottom-right.
+    ///
+    /// \param factors Normalized factors (x, y) within the bounds [0, 1]
+    ///
+    /// \return World coordinates of the calculated anchor point
+    ///
+    ////////////////////////////////////////////////////////////
+    ////////////////////////////////////////////////////////////
     [[nodiscard, gnu::always_inline, gnu::flatten, gnu::pure]] inline constexpr auto getAnchorPoint(const Vector2f factors) const
     {
         if constexpr (requires { static_cast<const T&>(*this).getGlobalBounds(); })
@@ -37,39 +59,50 @@
     }

 ////////////////////////////////////////////////////////////
-#define SFML_PRIV_DEFINE_MIXIN_GETTER(name, ...)                                                  \
+#define SFML_PRIV_DEFINE_MIXIN_GETTER(name, ...)                                                  \
+    /** \brief Get the position of the name anchor point */                                       \
     [[nodiscard, gnu::always_inline, gnu::flatten, gnu::pure]] inline constexpr auto name() const \
     {                                                                                             \
         return this->getAnchorPoint(__VA_ARGS__);                                                 \
     }

-    SFML_PRIV_DEFINE_MIXIN_GETTER(getTopLeft, {0.f, 0.f});
-    SFML_PRIV_DEFINE_MIXIN_GETTER(getTopCenter, {0.5f, 0.f});
-    SFML_PRIV_DEFINE_MIXIN_GETTER(getTopRight, {1.f, 0.f});
-    SFML_PRIV_DEFINE_MIXIN_GETTER(getCenterLeft, {0.f, 0.5f});
-    SFML_PRIV_DEFINE_MIXIN_GETTER(getCenter, {0.5f, 0.5f});
-    SFML_PRIV_DEFINE_MIXIN_GETTER(getCenterRight, {1.f, 0.5f});
-    SFML_PRIV_DEFINE_MIXIN_GETTER(getBottomLeft, {0.f, 1.f});
-    SFML_PRIV_DEFINE_MIXIN_GETTER(getBottomCenter, {0.5f, 1.f});
-    SFML_PRIV_DEFINE_MIXIN_GETTER(getBottomRight, {1.f, 1.f});
+    SFML_PRIV_DEFINE_MIXIN_GETTER(getTopLeft, {0.f, 0.f}); //!< \brief Get the position of the top-left anchor point \return World coordinates of the anchor
+    SFML_PRIV_DEFINE_MIXIN_GETTER(getTopCenter, {0.5f, 0.f}); //!< \brief Get the position of the top-center anchor point \return World coordinates of the anchor
+    SFML_PRIV_DEFINE_MIXIN_GETTER(getTopRight, {1.f, 0.f}); //!< \brief Get the position of the top-right anchor point \return World coordinates of the anchor
+    SFML_PRIV_DEFINE_MIXIN_GETTER(getCenterLeft, {0.f, 0.5f}); //!< \brief Get the position of the center-left anchor point \return World coordinates of the anchor
+    SFML_PRIV_DEFINE_MIXIN_GETTER(getCenter, {0.5f, 0.5f}); //!< \brief Get the position of the center anchor point \return World coordinates of the anchor
+    SFML_PRIV_DEFINE_MIXIN_GETTER(getCenterRight, {1.f, 0.5f}); //!< \brief Get the position of the center-right anchor point \return World coordinates of the anchor
+    SFML_PRIV_DEFINE_MIXIN_GETTER(getBottomLeft, {0.f, 1.f}); //!< \brief Get the position of the bottom-left anchor point \return World coordinates of the anchor
+    SFML_PRIV_DEFINE_MIXIN_GETTER(getBottomCenter, {0.5f, 1.f}); //!< \brief Get the position of the bottom-center anchor point \return World coordinates of the anchor
+    SFML_PRIV_DEFINE_MIXIN_GETTER(getBottomRight, {1.f, 1.f}); //!< \brief Get the position of the bottom-right anchor point \return World coordinates of the anchor

 #undef SFML_PRIV_DEFINE_MIXIN_GETTER

     ////////////////////////////////////////////////////////////
+    /// \brief Get the world X coordinate of the left edge
+    ///
+    /// \return Left edge X coordinate
+    ///
     ////////////////////////////////////////////////////////////
     [[nodiscard, gnu::always_inline, gnu::flatten, gnu::pure]] inline constexpr float getLeft() const
     {
         return static_cast<const T&>(*this).getGlobalBounds().getLeft();
     }

     ////////////////////////////////////////////////////////////
+    /// \brief Get the world X coordinate of the right edge
+    ///
+    /// \return Right edge X coordinate
+    ///
     ////////////////////////////////////////////////////////////
     [[nodiscard, gnu::always_inline, gnu::flatten, gnu::pure]] inline constexpr float getRight() const
     {
         return static_cast<const T&>(*this).getGlobalBounds().getRight();
     }

     ////////////////////////////////////////////////////////////
+    /// \brief Get the world Y coordinate of the top edge
+    ///
+    /// \return Top edge Y coordinate
+    ///
     ////////////////////////////////////////////////////////////
     [[nodiscard, gnu::always_inline, gnu::flatten, gnu::pure]] inline constexpr float getTop() const
     {
@@ -77,6 +110,10 @@
     }

     ////////////////////////////////////////////////////////////
+    /// \brief Get the world Y coordinate of the bottom edge
+    ///
+    /// \return Bottom edge Y coordinate
+    ///
     ////////////////////////////////////////////////////////////
     [[nodiscard, gnu::always_inline, gnu::flatten, gnu::pure]] inline constexpr float getBottom() const
     {
@@ -84,6 +121,13 @@
     }

     ////////////////////////////////////////////////////////////
+    /// \brief Set the object's position based on an anchor point
+    ///
+    /// Moves the object so that the anchor point specified by `factors`
+    /// aligns with the given `newPosition` in world coordinates.
+    ///
+    /// \param factors     Normalized factors (x, y) defining the anchor point
+    /// \param newPosition Target world coordinates for the anchor point
+    ///
+    ////////////////////////////////////////////////////////////
     [[gnu::always_inline, gnu::flatten]] inline constexpr void setAnchorPoint(const Vector2f factors, const Vector2f newPosition)
     {
         const auto& bounds = static_cast<const T&>(*this).getGlobalBounds();
@@ -91,33 +135,47 @@
     }

 ////////////////////////////////////////////////////////////
-#define SFML_PRIV_DEFINE_MIXIN_SETTER(name, ...)                                                \
+#define SFML_PRIV_DEFINE_MIXIN_SETTER(name, ...)                                                \
+    /** \brief Set the position based on the name anchor point */                               \
     [[gnu::always_inline, gnu::flatten]] inline constexpr void name(const Vector2f newPosition) \
     {                                                                                           \
         this->setAnchorPoint(__VA_ARGS__, newPosition);                                         \
     }

-    SFML_PRIV_DEFINE_MIXIN_SETTER(setTopLeft, {0.f, 0.f});
-    SFML_PRIV_DEFINE_MIXIN_SETTER(setTopCenter, {0.5f, 0.f});
-    SFML_PRIV_DEFINE_MIXIN_SETTER(setTopRight, {1.f, 0.f});
-    SFML_PRIV_DEFINE_MIXIN_SETTER(setCenterLeft, {0.f, 0.5f});
-    SFML_PRIV_DEFINE_MIXIN_SETTER(setCenter, {0.5f, 0.5f});
-    SFML_PRIV_DEFINE_MIXIN_SETTER(setCenterRight, {1.f, 0.5f});
-    SFML_PRIV_DEFINE_MIXIN_SETTER(setBottomLeft, {0.f, 1.f});
-    SFML_PRIV_DEFINE_MIXIN_SETTER(setBottomCenter, {0.5f, 1.f});
-    SFML_PRIV_DEFINE_MIXIN_SETTER(setBottomRight, {1.f, 1.f});
+    SFML_PRIV_DEFINE_MIXIN_SETTER(setTopLeft, {0.f, 0.f}); //!< \brief Set the position based on the top-left anchor \param newPosition Target world coordinates for the anchor
+    SFML_PRIV_DEFINE_MIXIN_SETTER(setTopCenter, {0.5f, 0.f}); //!< \brief Set the position based on the top-center anchor \param newPosition Target world coordinates for the anchor
+    SFML_PRIV_DEFINE_MIXIN_SETTER(setTopRight, {1.f, 0.f}); //!< \brief Set the position based on the top-right anchor \param newPosition Target world coordinates for the anchor
+    SFML_PRIV_DEFINE_MIXIN_SETTER(setCenterLeft, {0.f, 0.5f}); //!< \brief Set the position based on the center-left anchor \param newPosition Target world coordinates for the anchor
+    SFML_PRIV_DEFINE_MIXIN_SETTER(setCenter, {0.5f, 0.5f}); //!< \brief Set the position based on the center anchor \param newPosition Target world coordinates for the anchor
+    SFML_PRIV_DEFINE_MIXIN_SETTER(setCenterRight, {1.f, 0.5f}); //!< \brief Set the position based on the center-right anchor \param newPosition Target world coordinates for the anchor
+    SFML_PRIV_DEFINE_MIXIN_SETTER(setBottomLeft, {0.f, 1.f}); //!< \brief Set the position based on the bottom-left anchor \param newPosition Target world coordinates for the anchor
+    SFML_PRIV_DEFINE_MIXIN_SETTER(setBottomCenter, {0.5f, 1.f}); //!< \brief Set the position based on the bottom-center anchor \param newPosition Target world coordinates for the anchor
+    SFML_PRIV_DEFINE_MIXIN_SETTER(setBottomRight, {1.f, 1.f}); //!< \brief Set the position based on the bottom-right anchor \param newPosition Target world coordinates for the anchor

 #undef SFML_PRIV_DEFINE_MIXIN_SETTER

     ////////////////////////////////////////////////////////////
+    /// \brief Set the world X coordinate of the left edge
+    ///
+    /// This moves the entire object horizontally so its left edge
+    /// aligns with `newCoordinate`.
+    ///
+    /// \param newCoordinate Target X coordinate for the left edge
+    ///
     ////////////////////////////////////////////////////////////
     [[gnu::always_inline, gnu::flatten]] inline constexpr void setLeft(const float newCoordinate)
     {
         const auto& bounds = static_cast<const T&>(*this).getGlobalBounds();
         static_cast<T&>(*this).position.x += newCoordinate - bounds.position.x;
     }

     ////////////////////////////////////////////////////////////
+    /// \brief Set the world X coordinate of the right edge
+    ///
+    /// This moves the entire object horizontally so its right edge
+    /// aligns with `newCoordinate`.
+    ///
+    /// \param newCoordinate Target X coordinate for the right edge
+    ///
     ////////////////////////////////////////////////////////////
     [[gnu::always_inline, gnu::flatten]] inline constexpr void setRight(const float newCoordinate)
     {
@@ -126,6 +184,13 @@
     }

     ////////////////////////////////////////////////////////////
+    /// \brief Set the world Y coordinate of the top edge
+    ///
+    /// This moves the entire object vertically so its top edge
+    /// aligns with `newCoordinate`.
+    ///
+    /// \param newCoordinate Target Y coordinate for the top edge
+    ///
     ////////////////////////////////////////////////////////////
     [[gnu::always_inline, gnu::flatten]] inline constexpr void setTop(const float newCoordinate)
     {
@@ -134,6 +199,13 @@
     }

     ////////////////////////////////////////////////////////////
+    /// \brief Set the world Y coordinate of the bottom edge
+    ///
+    /// This moves the entire object vertically so its bottom edge
+    /// aligns with `newCoordinate`.
+    ///
+    /// \param newCoordinate Target Y coordinate for the bottom edge
+    ///
     ////////////////////////////////////////////////////////////
     [[gnu::always_inline, gnu::flatten]] inline constexpr void setBottom(const float newCoordinate)
     {
@@ -148,7 +220,17 @@
 /// \class sf::AnchorPointMixin
 /// \ingroup graphics
 ///
-/// TODO P1: docs
+/// Utility mixin providing convenient functions to get and set
+/// the position of an object based on anchor points relative
+/// to its bounding box (or size, for windows). These anchor points
+/// include corners (e.g., `getTopLeft()`, `setBottomRight()`),
+/// edge centers (e.g., `getCenterLeft()`, `setTopCenter()`), and the
+/// overall center (`getCenter()`, `setCenter()`).
+///
+/// It also provides functions to get or set the position based
+/// on individual edge coordinates (`getLeft()`, `setRight()`, etc.).
+///
+/// To use this mixin, inherit from it publicly, e.g.:
+/// `class MyObject : public sf::Transformable, public sf::AnchorPointMixin<MyObject>`
+/// The template argument `T` must be the type of the inheriting class itself.
+/// The inheriting class must provide `getGlobalBounds()` (or `getSize()` if
+/// bounds are not applicable, like for `sf::WindowBase`) and have a public
+/// `position` member of type `sf::Vector2f`.
 ///
 /// \see `sf::Transformable`, `sf::WindowBase`
 ///
--- a/Angle.hpp
+++ b/Angle.hpp
@@ -121,6 +121,16 @@
     }


-    /// TODO P1: docs
+    ////////////////////////////////////////////////////////////
+    /// \brief Rotate towards another angle by a maximum step.
+    ///
+    /// Calculates the shortest difference between `*this` and `other` (handling wrapping)
+    /// and returns a new angle by rotating `*this` towards `other` by at most `speed` radians.
+    /// If the shortest difference is less than or equal to `speed`, `other` is returned.
+    /// The result is normalized to the range [0, 2*Pi).
+    ///
+    /// \param other Target angle to rotate towards.
+    /// \param speed Maximum rotation step in radians. Must be non-negative.
+    ///
+    /// \return Angle rotated towards `other`, clamped by `speed`.
+    ///
+    ////////////////////////////////////////////////////////////
     [[nodiscard, gnu::always_inline, gnu::flatten, gnu::pure]] inline constexpr Angle rotatedTowards(const Angle other,
                                                                                                      const float speed) const
     {
--- a/AutoWrapAngle.hpp
+++ b/AutoWrapAngle.hpp
@@ -12,33 +12,43 @@
 namespace sf
 {
 ////////////////////////////////////////////////////////////
-/// \brief TODO P1: docs
+/// \brief A wrapper around sf::Angle that automatically wraps the angle value
+///
+/// This class behaves similarly to `sf::Angle` but automatically wraps
+/// the angle to the range [0, 360) degrees (or [0, 2*Pi) radians)
+/// whenever its value is accessed or used in comparisons/operations.
+/// This is useful for representing properties like rotation where only
+/// the final orientation matters, regardless of the number of full turns.
 ///
 ////////////////////////////////////////////////////////////
 class [[nodiscard]] AutoWrapAngle
 {
 public:
     ////////////////////////////////////////////////////////////
-    /// \brief TODO P1: docs
+    /// \brief Default constructor
+    ///
+    /// Initializes the angle to 0 degrees.
     ///
     ////////////////////////////////////////////////////////////
     [[nodiscard]] constexpr AutoWrapAngle() = default;

     ////////////////////////////////////////////////////////////
-    /// \brief TODO P1: docs
+    /// \brief Construct from an sf::Angle
+    ///
+    /// \param angle Angle to initialize from.
     ///
     ////////////////////////////////////////////////////////////
     [[nodiscard, gnu::always_inline, gnu::flatten]] inline constexpr explicit(false) AutoWrapAngle(Angle angle) :
     m_radians(angle.m_radians)
     {
     }

     ////////////////////////////////////////////////////////////
-    /// \brief TODO P1: docs
+    /// \brief Assign an sf::Angle
+    ///
+    /// \param angle Angle to assign.
+    /// \return Reference to `*this`.
     ///
     ////////////////////////////////////////////////////////////
     [[gnu::always_inline, gnu::flatten]] inline constexpr AutoWrapAngle& operator=(Angle angle) noexcept
@@ -48,7 +58,9 @@
     }

     ////////////////////////////////////////////////////////////
-    /// \brief TODO P1: docs
+    /// \brief Implicit conversion to sf::Angle
+    ///
+    /// Returns the angle value, wrapped to the range [0, 360).
     ///
     ////////////////////////////////////////////////////////////
     [[nodiscard, gnu::always_inline, gnu::flatten, gnu::pure]] inline constexpr operator Angle() const noexcept
@@ -77,7 +89,10 @@
     }

     ////////////////////////////////////////////////////////////
-    /// \brief TODO P1: docs
+    /// \brief Rotate towards another angle by a maximum step.
+    ///
+    /// Wraps the current angle before performing the rotation.
+    /// See `sf::Angle::rotatedTowards` for details.
     ///
     ////////////////////////////////////////////////////////////
     [[nodiscard, gnu::always_inline, gnu::flatten, gnu::pure]] inline constexpr Angle rotatedTowards(Angle other, float speed) const
@@ -86,13 +101,17 @@
     }

     ////////////////////////////////////////////////////////////
-    /// \brief TODO P1: docs
+    /// \brief Equality comparison operator
+    ///
+    /// Compares the underlying radian values without wrapping.
     ///
     ////////////////////////////////////////////////////////////
     friend constexpr bool operator==(AutoWrapAngle lhs, AutoWrapAngle rhs) = default;

     ////////////////////////////////////////////////////////////
-    /// \brief TODO P1: docs
+    /// \brief Addition assignment operator
+    ///
+    /// Adds `rhs` to the current angle value.
     ///
     ////////////////////////////////////////////////////////////
     [[gnu::always_inline, gnu::flatten]] inline constexpr AutoWrapAngle& operator+=(Angle rhs)
@@ -102,7 +121,9 @@
     }

     ////////////////////////////////////////////////////////////
-    /// \brief TODO P1: docs
+    /// \brief Subtraction assignment operator
+    ///
+    /// Subtracts `rhs` from the current angle value.
     ///
     ////////////////////////////////////////////////////////////
     [[gnu::always_inline, gnu::flatten]] inline constexpr AutoWrapAngle& operator-=(Angle rhs)
@@ -112,7 +133,9 @@
     }

     ////////////////////////////////////////////////////////////
-    /// \brief TODO P1: docs
+    /// \brief Multiplication assignment operator
+    ///
+    /// Multiplies the current angle value by `rhs`.
     ///
     ////////////////////////////////////////////////////////////
     [[gnu::always_inline, gnu::flatten]] inline constexpr AutoWrapAngle& operator*=(float rhs)
@@ -122,7 +145,9 @@
     }

     ////////////////////////////////////////////////////////////
-    /// \brief TODO P1: docs
+    /// \brief Division assignment operator
+    ///
+    /// Divides the current angle value by `rhs`. Asserts if `rhs` is 0.
     ///
     ////////////////////////////////////////////////////////////
     [[gnu::always_inline, gnu::flatten]] inline constexpr AutoWrapAngle& operator/=(float rhs)
@@ -132,7 +157,10 @@
     }

     ////////////////////////////////////////////////////////////
-    /// \brief TODO P1: docs
+    /// \brief Modulo assignment operator
+    ///
+    /// Assigns the result of `*this % rhs` to `*this`. Wraps the current angle
+    /// before performing the modulo operation. See `sf::Angle::operator%`.
     ///
     ////////////////////////////////////////////////////////////
     [[gnu::always_inline, gnu::flatten]] inline constexpr AutoWrapAngle& operator%=(Angle rhs)
@@ -148,7 +176,14 @@
 ////////////////////////////////////////////////////////////
 /// \class sf::AutoWrapAngle
 /// \ingroup system
-///
-/// TODO P1: docs
+///
+/// `sf::AutoWrapAngle` is a wrapper around `sf::Angle` that automatically
+/// normalizes the angle to the range [0, 360) degrees (or [0, 2*Pi) radians)
+/// upon access or use in operations.
+///
+/// This is particularly useful for representing properties like rotation
+/// where angles outside the standard range are equivalent (e.g., 450 degrees
+/// is the same orientation as 90 degrees). Using `AutoWrapAngle` ensures
+/// that comparisons and operations work intuitively in such cases.
 ///
 ////////////////////////////////////////////////////////////
--- a/FastSinCos.hpp
+++ b/FastSinCos.hpp
@@ -44,7 +44,12 @@
 namespace sf::base
 {
 ////////////////////////////////////////////////////////////
-/// \brief TODO P1: docs
+/// \brief Fast sine calculation using a lookup table.
+///
+/// Calculates an approximation of `sin(radians)` using a precomputed lookup table.
+/// This is faster than `std::sin` but less precise.
+///
+/// \param radians Angle in radians. Must be in the range [0, 2*Pi].
 ///
 ////////////////////////////////////////////////////////////
 [[nodiscard, gnu::always_inline, gnu::flatten, gnu::const]] inline constexpr float fastSin(const float radians) noexcept
@@ -58,7 +63,12 @@


 ////////////////////////////////////////////////////////////
-/// \brief TODO P1: docs
+/// \brief Fast cosine calculation using a lookup table.
+///
+/// Calculates an approximation of `cos(radians)` using a precomputed lookup table.
+/// This is faster than `std::cos` but less precise.
+///
+/// \param radians Angle in radians. Must be in the range [0, 2*Pi].
 ///
 ////////////////////////////////////////////////////////////
 [[nodiscard, gnu::always_inline, gnu::flatten, gnu::const]] inline constexpr float fastCos(const float radians) noexcept
@@ -72,7 +82,13 @@


 ////////////////////////////////////////////////////////////
-/// \brief TODO P1: docs
+/// \brief Fast sine and cosine calculation using a lookup table.
+///
+/// Calculates approximations of `sin(radians)` and `cos(radians)` simultaneously
+/// using a precomputed lookup table. Faster than separate calls to `fastSin` and `fastCos`.
+///
+/// \param radians Angle in radians. Must be in the range [0, 2*Pi].
+/// \return A struct containing the `sin` and `cos` results.
 ///
 ////////////////////////////////////////////////////////////
 [[nodiscard, gnu::always_inline, gnu::flatten, gnu::const]] inline constexpr auto fastSinCos(const float radians) noexcept
--- a/RectPacker.hpp
+++ b/RectPacker.hpp
@@ -15,38 +15,44 @@
 namespace sf
 {
 ////////////////////////////////////////////////////////////
-/// \brief TODO P1: docs
+/// \brief Packs 2D rectangles into a larger texture area efficiently.
+///
+/// This class implements the Shelf Bin Packer algorithm to find positions
+/// for smaller rectangles within a larger, fixed-size area (the "bin").
+/// It's commonly used for creating texture atlases, where multiple smaller
+/// images are packed into a single larger texture to optimize rendering.
 ///
 ////////////////////////////////////////////////////////////
 class RectPacker
 {
 public:
     ////////////////////////////////////////////////////////////
-    /// \brief TODO P1: docs
+    /// \brief Construct a rectangle packer for a given bin size.
+    ///
+    /// \param size The dimensions (width, height) of the area to pack rectangles into.
     ///
     ////////////////////////////////////////////////////////////
     [[nodiscard]] explicit RectPacker(Vector2u size);

     ////////////////////////////////////////////////////////////
-    /// \brief TODO P1: docs
+    /// \brief Destructor.
     ///
     ////////////////////////////////////////////////////////////
     ~RectPacker();

     ////////////////////////////////////////////////////////////
-    /// \brief Copy constructor
+    /// \brief Deleted copy constructor.
     ///
     ////////////////////////////////////////////////////////////
     RectPacker(const RectPacker& rhs) = delete;

     ////////////////////////////////////////////////////////////
-    /// \brief Copy assignment operator
+    /// \brief Deleted copy assignment operator.
     ///
     ////////////////////////////////////////////////////////////
     RectPacker& operator=(const RectPacker& rhs) = delete;

     ////////////////////////////////////////////////////////////
-    /// \brief Move constructor
+    /// \brief Move constructor.
     ///
     ////////////////////////////////////////////////////////////
     RectPacker(RectPacker&& rhs) noexcept;
@@ -57,13 +63,22 @@
     RectPacker& operator=(RectPacker&& rhs) noexcept;

     ////////////////////////////////////////////////////////////
-    /// \brief TODO P1: docs
+    /// \brief Attempt to pack a rectangle of the given size.
+    ///
+    /// Tries to find an available space within the bin for a rectangle
+    /// with the specified dimensions.
+    ///
+    /// \param rectSize The size (width, height) of the rectangle to pack.
+    ///                 Both dimensions must be greater than zero.
+    ///
+    /// \return An `Optional<Vector2u>` containing the top-left position
+    ///         where the rectangle was packed if successful, or `nullOpt`
+    ///         if there was no room left in the bin.
     ///
     ////////////////////////////////////////////////////////////
-    // TODO P1: add overload to pack multiple rects at once
     [[nodiscard]] base::Optional<Vector2u> pack(Vector2u rectSize);

     ////////////////////////////////////////////////////////////
-    /// \brief TODO P1: docs
+    /// \brief Get the size of the packing area (the bin).
     ///
     ////////////////////////////////////////////////////////////
     [[nodiscard]] Vector2u getSize() const;
@@ -79,7 +94,14 @@
 /// \class sf::RectPacker
 /// \ingroup system
 ///
-/// TODO P1: docs
+/// `sf::RectPacker` helps arrange smaller rectangular areas within a larger
+/// one without overlapping. This is useful for tasks like creating texture atlases,
+/// where you want to combine multiple small images into a single larger texture
+/// to improve performance.
+///
+/// You create a `RectPacker` with the dimensions of the target area (the "bin").
+/// Then, you repeatedly call `pack()` with the dimensions of the rectangles you
+/// want to place. `pack()` returns the top-left position within the bin where
+/// the rectangle was placed, or `nullOpt` if it couldn't fit.
 ///
 /// \see sf::Rect
 ///
--- a/RectUtils.hpp
+++ b/RectUtils.hpp
@@ -42,41 +42,15 @@
 }


+////////////////////////////////////////////////////////////
+/// \fn sf::findIntersection(const Rect<T>&, const Rect<T>&)
+/// \ingroup system
+///
+/// Checks if two rectangles overlap and, if they do, returns the
+/// rectangle representing their intersection.
+/// Handles rectangles with negative sizes correctly.
+///
+/// \param rect0 First rectangle.
+/// \param rect1 Second rectangle.
+/// \return `Optional<Rect<T>>` containing the intersection rectangle if they overlap, `nullOpt` otherwise.
+///
 ////////////////////////////////////////////////////////////
-/// \class sf::Rect
-/// \ingroup graphics
-///
-/// A rectangle is defined by its top-left corner and its size.
-/// It is a very simple class defined for convenience, so
-/// its member variables (position and size) are public
-/// and can be accessed directly, just like the vector classes
-/// (Vector2 and Vector3).
-///
-/// To keep things simple, `sf::Rect` doesn't define
-/// functions to emulate the properties that are not directly
-/// members (such as right, bottom, etc.), it rather
-/// only provides intersection functions.
-///
-/// `sf::Rect` uses the usual rules for its boundaries:
-/// \li The left and top edges are included in the rectangle's area
-/// \li The right and bottom edges are excluded from the rectangle's area
-///
-/// This means that `sf::IntRect({0, 0}, {1, 1})` and `sf::IntRect({1, 1}, {1, 1})`
-/// don't intersect.
-///
-/// sf::Rect is a template and may be used with any numeric type, but
-/// for simplicity type aliases for the instantiations used by SFML are given:
-/// \li sf::Rect<int> is sf::IntRect
-/// \li sf::Rect<float> is sf::FloatRect
-///
-/// So that you don't have to care about the template syntax.
-///
-/// Usage example:
-/// \code
-/// // Define a rectangle, located at (0, 0) with a size of 20x5
-/// sf::IntRect r1({0, 0}, {20, 5});
-///
-/// // Define another rectangle, located at (4, 2) with a size of 18x10
-/// sf::Vector2i position(4, 2);
-/// sf::Vector2i size(18, 10);
-/// sf::IntRect r2(position, size);
-///
-/// // Test intersections with the point (3, 1)
-/// bool b1 = r1.contains({3, 1}); // true
-/// bool b2 = r2.contains({3, 1}); // false
-///
-/// // Test the intersection between r1 and r2
-/// sf::base::Optional<sf::IntRect> result = r1.findIntersection(r2);
-/// // result.hasValue() == true
-/// // result.value() == sf::IntRect({4, 2}, {16, 3})
-/// \endcode
-///
-////////////////////////////////////////////////////////////
+
--- a/StringUtfUtils.hpp
+++ b/StringUtfUtils.hpp
@@ -10,6 +10,11 @@
 {
 class String;

+////////////////////////////////////////////////////////////
+/// \brief Utility class providing static functions for creating `sf::String` instances from UTF encoded data.
+///
+/// This class complements the standard `sf::String` constructors by providing explicit functions for creating strings from raw UTF-8, UTF-16, or UTF-32 encoded byte sequences.
+////////////////////////////////////////////////////////////
 class SFML_SYSTEM_API StringUtfUtils
 {
 public:
@@ -69,41 +74,4 @@
 #include "SFML/System/StringUtfUtils.inl"


-////////////////////////////////////////////////////////////
-/// \class sf::String
-/// \ingroup system
-///
-/// sf::String is a utility string class defined mainly for
-/// convenience. It is a Unicode string (implemented using
-/// UTF-32), thus it can store any character in the world
-/// (European, Chinese, Arabic, Hebrew, etc.).
-///
-/// It automatically handles conversions from/to ANSI and
-/// wide strings, so that you can work with standard string
-/// classes and still be compatible with functions taking a
-/// sf::String.
-///
-/// \code
-/// sf::String s;
-///
-/// std::string s1 = s;  // automatically converted to ANSI string
-/// std::wstring s2 = s; // automatically converted to wide string
-/// s = "hello";         // automatically converted from ANSI string
-/// s = L"hello";        // automatically converted from wide string
-/// s += 'a';            // automatically converted from ANSI string
-/// s += L'a';           // automatically converted from wide string
-/// \endcode
-///
-/// Conversions involving ANSI strings use the default user locale. However
-/// it is possible to use a custom locale if necessary:
-/// \code
-/// std::locale locale;
-/// sf::String s;
-/// ...
-/// std::string s1 = s.toAnsiString(locale);
-/// s = sf::String("hello", locale);
-/// \endcode
-///
-/// sf::String defines the most important functions of the
-/// standard std::string class: removing, random access, iterating,
-/// appending, comparing, etc. However it is a simple class
-/// provided for convenience, and you may have to consider using
-/// a more optimized class if your program requires complex string
-/// handling. The automatic conversion functions will then take
-/// care of converting your string to sf::String whenever SFML
-/// requires it.
-///
-/// Please note that SFML also defines a low-level, generic
-/// interface for Unicode handling, see the sf::Utf classes.
-///
-////////////////////////////////////////////////////////////
--- a/ThreadPool.hpp
+++ b/ThreadPool.hpp
@@ -15,33 +15,48 @@
 namespace sf::base
 {
 ////////////////////////////////////////////////////////////
-/// \brief TODO P1: docs
+/// \brief Manages a pool of worker threads to execute tasks concurrently.
+///
+/// This class provides a simple way to offload work to a fixed number
+/// of background threads. Tasks are submitted using the `post` method
+/// and are executed by the next available worker thread.
 ///
 ////////////////////////////////////////////////////////////
 class ThreadPool
 {
 public:
     ////////////////////////////////////////////////////////////
-    /// \brief TODO P1: docs
+    /// \brief The type of task that can be executed by the pool.
+    ///
+    /// Uses `sf::base::FixedFunction` for non-allocating storage.
     ///
     ////////////////////////////////////////////////////////////
     using Task = FixedFunction<void(), 128>;

     ////////////////////////////////////////////////////////////
-    /// \brief TODO P1: docs
+    /// \brief Construct a thread pool with a specified number of workers.
+    ///
+    /// Creates and starts `workerCount` threads that will wait for tasks.
+    ///
+    /// \param workerCount The number of worker threads to create.
     ///
     ////////////////////////////////////////////////////////////
     explicit ThreadPool(SizeT workerCount);

     ////////////////////////////////////////////////////////////
-    /// \brief TODO P1: docs
+    /// \brief Destructor.
+    ///
+    /// Waits for all currently executing and pending tasks to complete,
+    /// then stops and joins all worker threads.
     ///
     ////////////////////////////////////////////////////////////
     ~ThreadPool();

     ////////////////////////////////////////////////////////////
-    /// \brief TODO P1: docs
+    /// \brief Post a task to be executed by a worker thread.
+    ///
+    /// The task will be added to the queue and executed by the next
+    /// available worker thread.
+    ///
+    /// \param f The task (a callable object taking no arguments and returning void) to execute.
     ///
     ////////////////////////////////////////////////////////////
     void post(Task&& f);
@@ -55,7 +70,10 @@
     [[nodiscard]] SizeT getWorkerCount() const noexcept;

     ////////////////////////////////////////////////////////////
-    /// \brief TODO P1: docs
+    /// \brief Get the number of concurrent threads supported by the hardware.
+    ///
+    /// Provides a hint about the optimal number of threads for CPU-bound tasks.
+    /// Equivalent to `std::thread::hardware_concurrency`.
     ///
     ////////////////////////////////////////////////////////////
     [[nodiscard]] static SizeT getHardwareWorkerCount() noexcept;
--- a/TimeChronoUtil.hpp
+++ b/TimeChronoUtil.hpp
@@ -13,7 +13,10 @@
 namespace sf
 {
 ////////////////////////////////////////////////////////////
-/// \brief Interoperability utilities between `sf::Time` and `<chrono>`
+/// \brief Utilities for converting between `sf::Time` and `<chrono>` durations.
+///
+/// This class provides static functions to facilitate seamless conversion
+/// between SFML's `sf::Time` and the standard C++ `<chrono>` library's duration types.
 ///
 ////////////////////////////////////////////////////////////
 class SFML_SYSTEM_API TimeChronoUtil
@@ -22,6 +25,10 @@
     ////////////////////////////////////////////////////////////
     /// \brief Create a `Time` from a `std::chrono::duration`
     ///
+    /// Converts any `std::chrono::duration` type into an equivalent `sf::Time`.
+    ///
+    /// \param duration The `std::chrono::duration` to convert.
+    /// \return The equivalent `sf::Time` value.
     ////////////////////////////////////////////////////////////
     template <typename Rep, typename Period>
     [[nodiscard]] static constexpr Time fromDuration(const std::chrono::duration<Rep, Period>& duration)
@@ -33,7 +40,8 @@
     ////////////////////////////////////////////////////////////
     /// \brief Convert `time` to a `std::chrono::microseconds` duration
     ///
-    /// \return Time in microseconds
+    /// \param time The `sf::Time` to convert.
+    /// \return The equivalent duration in `std::chrono::microseconds`.
     ///
     ////////////////////////////////////////////////////////////
     [[nodiscard]] static constexpr std::chrono::microseconds toDuration(const Time time)
@@ -44,7 +52,8 @@
     ////////////////////////////////////////////////////////////
     /// \brief Convert `time` to a custom `std::chrono::duration`
     ///
-    /// \return Duration in microseconds
+    /// \param time The `sf::Time` to convert.
+    /// \return The equivalent duration represented by the specified `std::chrono::duration` template instantiation.
     ///
     ////////////////////////////////////////////////////////////
     template <typename Rep, typename Period>
@@ -58,7 +67,10 @@
 /// \class sf::TimeChronoUtil
 /// \ingroup system
 ///
-/// Interoperability utilities between `sf::Time` and `<chrono>`
+/// The `sf::TimeChronoUtil` class provides static helper functions to simplify
+/// the conversion between SFML's time representation (`sf::Time`) and the
+/// standard C++ time library (`<chrono>`). This allows for easier integration
+/// with other libraries or code that uses `std::chrono`.
 ///
 /// \see sf::Time, sf::Clock
 ///
