#pragma once
#include <SFML/Copyright.hpp> // LICENSE AND COPYRIGHT (C) INFORMATION

////////////////////////////////////////////////////////////
// Headers
////////////////////////////////////////////////////////////
#include "SFML/Graphics/Export.hpp"

#include "SFML/Graphics/Transformable.hpp"
#include "SFML/Graphics/Vertex.hpp"

#include "SFML/Base/Macros.hpp"
#include "SFML/Base/SizeT.hpp"
#include "SFML/Base/TrivialVector.hpp"


////////////////////////////////////////////////////////////
// Forward declarations
////////////////////////////////////////////////////////////
namespace sf
{
template <typename TBufferObject>
class GLPersistentBuffer;

class RenderTarget;
class Shape;
class Text;
struct GLElementBufferObject;
struct GLVertexBufferObject;
struct Sprite;
struct Transform;

struct CircleShapeData;
struct EllipseShapeData;
struct RectangleShapeData;
struct RoundedRectangleShapeData;
} // namespace sf


namespace sf
{
////////////////////////////////////////////////////////////
/// \brief TODO P1: docs
///
////////////////////////////////////////////////////////////
using IndexType = unsigned int;

} // namespace sf


namespace sf::priv
{
////////////////////////////////////////////////////////////
/// \brief TODO P1: docs
///
////////////////////////////////////////////////////////////
struct CPUStorage
{
    ////////////////////////////////////////////////////////////
    [[gnu::always_inline, gnu::flatten]] void clear()
    {
        vertices.clear();
        indices.clear();
    }

    ////////////////////////////////////////////////////////////
    [[nodiscard, gnu::always_inline, gnu::flatten]] Vertex* reserveMoreVertices(const base::SizeT count)
    {
        return vertices.reserveMore(count);
    }

    ////////////////////////////////////////////////////////////
    [[nodiscard, gnu::always_inline, gnu::flatten]] IndexType* reserveMoreIndices(const base::SizeT count)
    {
        return indices.reserveMore(count);
    }

    ////////////////////////////////////////////////////////////
    [[gnu::always_inline, gnu::flatten]] void commitMoreVertices(const base::SizeT count)
    {
        vertices.unsafeSetSize(vertices.size() + count);
    }

    ////////////////////////////////////////////////////////////
    [[gnu::always_inline, gnu::flatten]] void commitMoreIndices(const base::SizeT count)
    {
        indices.unsafeSetSize(indices.size() + count);
    }

    ////////////////////////////////////////////////////////////
    [[nodiscard, gnu::always_inline, gnu::flatten, gnu::pure]] IndexType getNumVertices() const
    {
        return static_cast<IndexType>(vertices.size());
    }

    ////////////////////////////////////////////////////////////
    [[nodiscard, gnu::always_inline, gnu::flatten, gnu::pure]] IndexType getNumIndices() const
    {
        return static_cast<IndexType>(indices.size());
    }

    ////////////////////////////////////////////////////////////
    // Member data
    ////////////////////////////////////////////////////////////
    base::TrivialVector<Vertex>    vertices; //!< CPU buffer for vertices
    base::TrivialVector<IndexType> indices;  //!< CPU buffer for indices
};

////////////////////////////////////////////////////////////
/// \brief TODO P1: docs
///
////////////////////////////////////////////////////////////
struct PersistentGPUStorage
{
    ////////////////////////////////////////////////////////////
    explicit PersistentGPUStorage(RenderTarget& renderTarget); // TODO P1: bad coupling here

    ////////////////////////////////////////////////////////////
    [[gnu::always_inline]] void clear()
    {
        nVertices = nIndices = 0u;
    }

    ////////////////////////////////////////////////////////////
    [[nodiscard]] Vertex*    reserveMoreVertices(base::SizeT count);
    [[nodiscard]] IndexType* reserveMoreIndices(base::SizeT count);

    ////////////////////////////////////////////////////////////
    [[gnu::always_inline]] void commitMoreVertices(const base::SizeT count)
    {
        nVertices += static_cast<IndexType>(count);
    }

    ////////////////////////////////////////////////////////////
    [[gnu::always_inline]] void commitMoreIndices(const base::SizeT count)
    {
        nIndices += static_cast<IndexType>(count);
    }

    ////////////////////////////////////////////////////////////
    [[nodiscard, gnu::always_inline, gnu::flatten, gnu::pure]] IndexType getNumVertices() const
    {
        return nVertices;
    }

    ////////////////////////////////////////////////////////////
    [[nodiscard, gnu::always_inline, gnu::flatten, gnu::pure]] IndexType getNumIndices() const
    {
        return nIndices;
    }

    ////////////////////////////////////////////////////////////
    // Member data
    ////////////////////////////////////////////////////////////
    GLPersistentBuffer<GLVertexBufferObject>&  vboPersistentBuffer; //!< GPU persistent buffer for vertices
    GLPersistentBuffer<GLElementBufferObject>& eboPersistentBuffer; //!< GPU persistent buffer for indices

    IndexType nVertices{}; //!< Number of "active" vertices in the buffer
    IndexType nIndices{};  //!< Number of "active" indices in the buffer
};

////////////////////////////////////////////////////////////
/// \brief TODO P1: docs
///
////////////////////////////////////////////////////////////
template <typename TStorage>
class [[nodiscard]] SFML_GRAPHICS_API DrawableBatchImpl : public Transformable
{
public:
    ////////////////////////////////////////////////////////////
    /// \brief TODO P1: docs
    ///
    ////////////////////////////////////////////////////////////
    template <typename... TStorageArgs>
    explicit DrawableBatchImpl(TStorageArgs&&... storageArgs) : m_storage(SFML_BASE_FORWARD(storageArgs)...)
    {
    }

    ////////////////////////////////////////////////////////////
    /// \brief TODO P1: docs
    ///
    ////////////////////////////////////////////////////////////
    void addTriangles(const Transform& transform, const Vertex* data, base::SizeT size);

    ////////////////////////////////////////////////////////////
    /// \brief TODO P1: docs
    ///
    ////////////////////////////////////////////////////////////
    void add(const Sprite& sprite);

    ////////////////////////////////////////////////////////////
    /// \brief TODO P1: docs
    ///
    ////////////////////////////////////////////////////////////
    void add(const Shape& shape);

    ////////////////////////////////////////////////////////////
    /// \brief TODO P1: docs
    ///
    ////////////////////////////////////////////////////////////
    void add(const Text& text);

    ////////////////////////////////////////////////////////////
    /// \brief TODO P1: docs
    ///
    ////////////////////////////////////////////////////////////
    void add(const CircleShapeData& sdCircle);

    ////////////////////////////////////////////////////////////
    /// \brief TODO P1: docs
    ///
    ////////////////////////////////////////////////////////////
    void add(const EllipseShapeData& sdEllipse);

    ////////////////////////////////////////////////////////////
    /// \brief TODO P1: docs
    ///
    ////////////////////////////////////////////////////////////
    void add(const RectangleShapeData& sdRectangle);

    ////////////////////////////////////////////////////////////
    /// \brief TODO P1: docs
    ///
    ////////////////////////////////////////////////////////////
    void add(const RoundedRectangleShapeData& sdRoundedRectangle);

    ////////////////////////////////////////////////////////////
    /// \brief TODO P1: docs
    ///
    ////////////////////////////////////////////////////////////
    void clear();

private:
    friend RenderTarget;

    ////////////////////////////////////////////////////////////
    /// \brief TODO P1: docs
    ///
    ////////////////////////////////////////////////////////////
    void drawShapeFromPoints(base::SizeT nPoints, const auto& descriptor, auto&& pointFn);

    ////////////////////////////////////////////////////////////
    /// \brief TODO P1: docs
    ///
    ////////////////////////////////////////////////////////////
    void addShapeFill(const Transform& transform, const Vertex* data, base::SizeT size);

    ////////////////////////////////////////////////////////////
    /// \brief TODO P1: docs
    ///
    ////////////////////////////////////////////////////////////
    void addShapeOutline(const Transform& transform, const Vertex* data, base::SizeT size);

    ////////////////////////////////////////////////////////////
    // Member data
    ////////////////////////////////////////////////////////////
    TStorage m_storage;
};

////////////////////////////////////////////////////////////
// Explicit instantiation declarations
////////////////////////////////////////////////////////////
extern template class DrawableBatchImpl<CPUStorage>;
extern template class DrawableBatchImpl<PersistentGPUStorage>;

} // namespace sf::priv


namespace sf
{
////////////////////////////////////////////////////////////
/// \brief TODO P1: docs
///
////////////////////////////////////////////////////////////
class CPUDrawableBatch : public priv::DrawableBatchImpl<priv::CPUStorage>
{
    using DrawableBatchImpl<priv::CPUStorage>::DrawableBatchImpl;
};

////////////////////////////////////////////////////////////
/// \brief TODO P1: docs
///
////////////////////////////////////////////////////////////
class PersistentGPUDrawableBatch : public priv::DrawableBatchImpl<priv::PersistentGPUStorage>
{
    using DrawableBatchImpl<priv::PersistentGPUStorage>::DrawableBatchImpl;
};

} // namespace sf


////////////////////////////////////////////////////////////
/// \class sf::DrawableBatch
/// \ingroup graphics
///
/// TODO P1: docs
///
/// \see `sf::RenderTarget`
///
////////////////////////////////////////////////////////////
