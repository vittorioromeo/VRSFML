#pragma once
#include <SFML/Copyright.hpp> // LICENSE AND COPYRIGHT (C) INFORMATION


////////////////////////////////////////////////////////////
// Headers
////////////////////////////////////////////////////////////
#include "SFML/Graphics/Export.hpp"

#include "SFML/Window/ContextSettings.hpp"

#include "SFML/Base/InPlacePImpl.hpp"
#include "SFML/Base/Optional.hpp"
#include "SFML/Base/PassKey.hpp"


////////////////////////////////////////////////////////////
// Forward declarations
////////////////////////////////////////////////////////////
namespace sf
{
class RenderTarget;
class Shader;
class Texture;
class WindowContext;
} // namespace sf


namespace sf
{
////////////////////////////////////////////////////////////
/// \brief TODO P1: docs
///
////////////////////////////////////////////////////////////
class [[nodiscard]] SFML_GRAPHICS_API GraphicsContext
{
public:
    ////////////////////////////////////////////////////////////
    /// \brief Create a new graphics context TODO P1: docs
    ///
    ////////////////////////////////////////////////////////////
    [[nodiscard]] static base::Optional<GraphicsContext> create(const ContextSettings& sharedContextSettings = {});

    ////////////////////////////////////////////////////////////
    /// \private
    ///
    /// \brief Default constructor
    ///
    ////////////////////////////////////////////////////////////
    [[nodiscard]] explicit GraphicsContext(base::PassKey<GraphicsContext>&&, WindowContext&& windowContext);

    ////////////////////////////////////////////////////////////
    /// \brief Destructor
    ///
    ////////////////////////////////////////////////////////////
    ~GraphicsContext();

    // Deleted copy operations
    GraphicsContext(const GraphicsContext&)            = delete;
    GraphicsContext& operator=(const GraphicsContext&) = delete;

    ////////////////////////////////////////////////////////////
    /// \brief TODO P1: docs
    ///
    ////////////////////////////////////////////////////////////
    GraphicsContext(GraphicsContext&& rhs) noexcept;

    // Deleted move assignment
    GraphicsContext& operator=(GraphicsContext&& rhs) = delete;

    ////////////////////////////////////////////////////////////
    /// \brief Returns the built-in shader
    ///
    ////////////////////////////////////////////////////////////
    [[nodiscard]] Shader& getBuiltInShader() const;

    ////////////////////////////////////////////////////////////
    /// \brief Returns the built-in 1x1 white texture
    ///
    ////////////////////////////////////////////////////////////
    [[nodiscard]] Texture& getBuiltInWhiteDotTexture() const;

    ////////////////////////////////////////////////////////////
    /// \brief Returns `true` if a `GraphicsContext` is installed
    ///
    ////////////////////////////////////////////////////////////
    [[nodiscard]] static bool isInstalled();

    ////////////////////////////////////////////////////////////
    /// \brief Get the currently active context's ID
    ///
    /// The context ID is used to identify contexts when
    /// managing unshareable OpenGL resources.
    ///
    /// \return The active context's ID or 0 if no context is currently active
    ///
    ////////////////////////////////////////////////////////////
    [[nodiscard]] static unsigned int getActiveThreadLocalGlContextId();

    ////////////////////////////////////////////////////////////
    /// \brief TODO P1: docs
    ///
    ////////////////////////////////////////////////////////////
    [[nodiscard]] static bool hasActiveThreadLocalGlContext();

    ////////////////////////////////////////////////////////////
    /// \brief TODO P1: docs
    ///
    ////////////////////////////////////////////////////////////
    using UnsharedDeleteFn = void (*)(unsigned int);

    ////////////////////////////////////////////////////////////
    /// \brief Register an OpenGL object to be destroyed when its containing context is destroyed
    ///
    /// This is used for internal purposes in order to properly
    /// clean up OpenGL resources that cannot be shared between
    /// contexts.
    ///
    /// \param object Object to be destroyed when its containing context is destroyed
    ///
    ////////////////////////////////////////////////////////////
    static void registerUnsharedFrameBuffer(unsigned int glContextId, unsigned int frameBufferId, UnsharedDeleteFn deleteFn);

    ////////////////////////////////////////////////////////////
    /// \brief Unregister an OpenGL object from its containing context
    ///
    /// \param object Object to be unregister
    ///
    ////////////////////////////////////////////////////////////
    static void unregisterUnsharedFrameBuffer(unsigned int glContextId, unsigned int frameBufferId);

private:
    friend Shader;
    friend RenderTarget;

    ////////////////////////////////////////////////////////////
    /// \brief Returns the built-in shader (private `static` version)
    ///
    ////////////////////////////////////////////////////////////
    [[nodiscard]] static Shader& getInstalledBuiltInShader();

    ////////////////////////////////////////////////////////////
    /// \brief Returns the built-in 1x1 white texture (private `static` version)
    ///
    ////////////////////////////////////////////////////////////
    [[nodiscard]] static Texture& getInstalledBuiltInWhiteDotTexture();

    ////////////////////////////////////////////////////////////
    // Member data
    ////////////////////////////////////////////////////////////
    struct Impl;
    base::InPlacePImpl<Impl, 64> m_impl; //!< Implementation details
};

} // namespace sf


////////////////////////////////////////////////////////////
/// \class sf::GraphicsContext
/// \ingroup graphics
///
/// TODO P1: docs
///
/// \see sf::GraphicsContext
///
////////////////////////////////////////////////////////////
